#include "common.h"

/*
一个 n 个节点的无向树，节点编号为 0 到 n - 1 ，树的根结点是 0 号节点。给你一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] ，表示节点 ai 和 bi 在树中有一条边。

在每一个节点 i 处有一扇门。同时给你一个都是偶数的数组 amount ，其中 amount[i] 表示：

如果 amount[i] 的值是负数，那么它表示打开节点 i 处门扣除的分数。
如果 amount[i] 的值是正数，那么它表示打开节点 i 处门加上的分数。
游戏按照如下规则进行：

一开始，Alice 在节点 0 处，Bob 在节点 bob 处。
每一秒钟，Alice 和 Bob 分别 移动到相邻的节点。Alice 朝着某个 叶子结点 移动，Bob 朝着节点 0 移动。
对于他们之间路径上的 每一个 节点，Alice 和 Bob 要么打开门并扣分，要么打开门并加分。注意：
如果门 已经打开 （被另一个人打开），不会有额外加分也不会扣分。
如果 Alice 和 Bob 同时 到达一个节点，他们会共享这个节点的加分或者扣分。换言之，如果打开这扇门扣 c 分，那么 Alice 和 Bob 分别扣 c / 2 分。如果这扇门的加分为 c ，那么他们分别加 c / 2 分。
如果 Alice 到达了一个叶子结点，她会停止移动。类似的，如果 Bob 到达了节点 0 ，他也会停止移动。注意这些事件互相 独立 ，不会影响另一方移动。
请你返回 Alice 朝最优叶子结点移动的 最大 净得分。


示例 1：



输入：edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
输出：6
解释：
上图展示了输入给出的一棵树。游戏进行如下：
- Alice 一开始在节点 0 处，Bob 在节点 3 处。他们分别打开所在节点的门。
  Alice 得分为 -2 。
- Alice 和 Bob 都移动到节点 1 。
  因为他们同时到达这个节点，他们一起打开门并平分得分。
  Alice 的得分变为 -2 + (4 / 2) = 0 。
- Alice 移动到节点 3 。因为 Bob 已经打开了这扇门，Alice 得分不变。
  Bob 移动到节点 0 ，并停止移动。
- Alice 移动到节点 4 并打开这个节点的门，她得分变为 0 + 6 = 6 。
现在，Alice 和 Bob 都不能进行任何移动了，所以游戏结束。
Alice 无法得到更高分数。
示例 2：



输入：edges = [[0,1]], bob = 1, amount = [-7280,2350]
输出：-7280
解释：
Alice 按照路径 0->1 移动，同时 Bob 按照路径 1->0 移动。
所以 Alice 只打开节点 0 处的门，她的得分为 -7280 。


提示：

2 <= n <= 105
edges.length == n - 1
edges[i].length == 2
0 <= ai, bi < n
ai != bi
edges 表示一棵有效的树。
1 <= bob < n
amount.length == n
amount[i] 是范围 [-104, 104] 之间的一个 偶数 。
*/

class Solution {
public:
    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        int n = amount.size();
        vector<vector<int>> g(n, vector<int>());
        for(auto edge: edges) {
            g[edge[0]].push_back(edge[1]);
            g[edge[1]].push_back(edge[0]);
        }
        vector<int> pa(n, 0), a(n, 0), b(n, n + 1);
        // 计算图中父子关系，以及a的深度
        function<void(int, int, int)> dfs1 = [&](int sn, int fa, int d) {
            pa[sn] = fa;
            a[sn] = d;
            for(auto fn: g[sn]) if (fn != fa) dfs1(fn, sn, d + 1);
        };
        dfs1(0, -1, 0);
        for(int sn = bob, i = 0; sn >= 0; sn = pa[sn], i++) b[sn] = i;
        int res = INT_MIN;
        function<void(int, int)> dfs2 = [&](int sn, int tot) {
            if(a[sn] < b[sn]) { tot += amount[sn]; }
            else if ( a[sn] == b[sn]) {
                tot += (amount[sn] / 2);
            }
            bool changed = false;
            for(auto fn: g[sn]) if (fn != pa[sn]) {
                dfs2(fn, tot);
                changed = true;
            }
            if (!changed) res = max(tot, res);
        };
        dfs2(0, 0);
        return res;
    }
};




void TestSolution() {
    Solution s;
    vector<vector<int>> edges ={{0,42},{0,59},{1,35},{1,76},{1,53},{2,46},{2,76},{3,21},{4,40},{4,54},{5,38},{5,84},{6,30},{6,16},{6,75},{6,52},{7,87},{8,34},{9,11},{9,43},{10,18},{10,48},{11,32},{12,79},{12,58},{12,13},{13,41},{13,34},{14,85},{14,15},{15,17},{15,82},{16,45},{17,21},{17,27},{19,58},{20,25},{22,87},{23,67},{23,89},{24,34},{25,79},{26,55},{28,49},{28,33},{29,43},{31,32},{33,43},{33,71},{33,53},{34,74},{34,89},{36,61},{37,51},{37,52},{39,69},{44,78},{47,87},{47,50},{48,63},{48,66},{49,70},{49,82},{50,58},{52,54},{52,69},{52,89},{53,57},{55,57},{55,88},{56,61},{58,61},{59,68},{59,66},{59,84},{59,86},{60,88},{62,74},{63,72},{64,71},{65,73},{65,86},{65,85},{69,80},{73,81},{74,88},{77,87},{78,86},{81,83}};
    vector<int> amount = {-6264,-9124,2696,-3014,-6,-9776,5402,-9380,3366,6968,-8022,842,-7192,9026,-2486,-858,-6854,-9142,4946,8124,-828,-3372,1794,-4188,-4236,-1346,-8088,6016,4020,4900,-9878,-5840,2852,3286,9444,220,-5896,-9414,2938,6316,6698,-7146,2270,-2308,-8446,-9372,8950,4234,-2706,7936,6380,8030,86,8184,-8636,-4124,-2058,-2044,-4160,6384,90,4256,266,4096,8982,-6456,1510,7284,-7954,1226,5966,7602,-4390,-3556,-7648,3400,-2760,-9520,-3986,8640,-7778,6622,-8718,8230,3058,30,2084,3140,4800,-3634};
    cout << s.mostProfitablePath(edges, 53, amount) << endl;
}
